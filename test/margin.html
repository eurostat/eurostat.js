<!DOCTYPE html>
<svg></svg>
<link rel="stylesheet" type="text/css" href="style.css">
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://d3js.org/d3-request.v1.min.js"></script>
<script src="https://d3js.org/topojson.v3.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://unpkg.com/jsts@1.6.1/dist/jsts.min.js"></script>
<script>
    d3.json("https://raw.githubusercontent.com/eurostat/Nuts2json/master/2016/3035/60M/0.json",
        function (error, nuts) {
            if (error) throw error;

            //prepare SVG element
            var width = 700, height = width * (nuts.bbox[3] - nuts.bbox[1]) / (nuts.bbox[2] - nuts.bbox[0]),
                svg = d3.select("svg").attr("width", width).attr("height", height),
                path = d3.geoPath().projection(d3.geoIdentity()
                    .reflectY(true).fitSize([width, height], topojson.feature(nuts, nuts.objects.gra)));

            //jsts functions
            var reader = new jsts.io.GeoJSONReader();
            var writer = new jsts.io.GeoJSONWriter();
            var buffer = function (geom, dist) {
                var buffer = reader.read(geom).buffer(dist);
                return writer.write(buffer);
            };

            //prepare data
            //country regions
            var cnts = topojson.feature(nuts, nuts.objects.cntrg).features;
            //NUTS regions
            var nutsrg = topojson.feature(nuts, nuts.objects.nutsrg).features;

            //draw coastal margin with JSTS buffer
            var dist = 200000;
            for (var i = 1; i >= 0; i -= 0.2) {
                var col = d3.interpolateBlues(1 - i);
                svg.append("g").selectAll("path").data(cnts)
                    .enter().append("path").attr("d", function (cnt) {
                        return path(buffer(cnt.geometry, i * dist));
                    }).style("fill", col);
                svg.append("g").selectAll("path").data(nutsrg)
                    .enter().append("path").attr("d", function (cnt) {
                        return path(buffer(cnt.geometry, i * dist));
                    }).style("fill", col);
            }

            //draw graticule
            svg.append("g").selectAll("path").data(topojson.feature(nuts, nuts.objects.gra).features)
                .enter().append("path").attr("d", path).attr("class", "graticule");

            //draw regions
            //countries
            svg.append("g").selectAll("path").data(cnts)
                .enter().append("path").attr("d", path).attr("class", "cntrg");

            //nuts
            svg.append("g").selectAll("path").data(nutsrg)
                .enter().append("path").attr("d", path).attr("class", "nutsrg");

            //draw boundaries
            //countries
            svg.append("g").selectAll("path").data(topojson.feature(nuts, nuts.objects.cntbn).features)
                .enter().append("path").attr("d", path)
                .attr("class", function (bn) { return "cntbn" + (bn.properties.co === "T" ? " coastal" : ""); });
            //nuts
            svg.append("g").selectAll("path").data(topojson.feature(nuts, nuts.objects.nutsbn).features)
                .enter().append("path").attr("d", path)
                .attr("class", function (bn) {
                    return "nutsbn" + (bn.properties.co === "T" ? " coastal" : "")
                        + ((bn.properties.oth === "T" || bn.properties.lvl == 0) ? " white" : "")
                        + (bn.properties.lvl == 3 ? " thin" : "");
                });

        });
</script>
